<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-20T02:40:40.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    <email>776824297@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Openstack如何进行代码调试</title>
    <link href="http://yoursite.com/2017/12/08/openstack-python-pdb/"/>
    <id>http://yoursite.com/2017/12/08/openstack-python-pdb/</id>
    <published>2017-12-08T11:40:04.000Z</published>
    <updated>2017-12-20T02:40:40.956Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍Openstack的代码调试之前，先熟悉下在Python中是如何进行代码调试的。<br><a id="more"></a></p>
<h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>说到Python的代码调试，难道是满屏幕的<code>print</code>？肯定不是这样的，Python作为一种非常强大的语言，肯定不会让你的调试之路充满<code>print</code>，接下来就介绍下Python中进行代码调试的pdb工具。</p>
<p>pdb 是 python 自带的一个包，为 python程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。</p>
<p>直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># coding=utf-8</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import pdb; pdb.set_trace()</div></pre></td></tr></table></figure></p>
<p>执行代码时，会出现一个友好的交互界面，然后就可以愉快的<code>print</code>了。</p>
<h3 id="pudb"><a href="#pudb" class="headerlink" title="pudb"></a>pudb</h3><p><code>pudb</code>跟<code>pdb</code>相比，就显得比较高大上了，<code>pudb</code>提供了图形化界面，而且是彩色的，但是使用之前需要安装<code>pudb</code>库，安装方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pudb</div></pre></td></tr></table></figure></p>
<p><code>pudb</code>提供了图形化界面, 同样的它也可以设置断点，而且侧边栏会显示调用栈和变量（尤其是变量），他的命令和<code>pdb</code>完全一样。</p>
<p>直接上图：<img src="http://ot8956ufo.bkt.clouddn.com/python_pudb.png" alt="pudb"></p>
<p><code>pudb</code>的交互效果明显比<code>pdb</code>更好，而且可以很想象的将调试过程图像化，调试起来更加高效和方便。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>break 或 b</td>
<td>设置断点</td>
</tr>
<tr>
<td>continue 或 c</td>
<td>继续执行程序</td>
</tr>
<tr>
<td>list 或 l</td>
<td>查看当前行的代码段</td>
</tr>
<tr>
<td>step 或 s</td>
<td>进入函数</td>
</tr>
<tr>
<td>return 或 r</td>
<td>执行代码直到从当前函数返回</td>
</tr>
<tr>
<td>exit 或 q</td>
<td>中止并退出</td>
</tr>
<tr>
<td>next 或 n</td>
<td>执行下一行</td>
</tr>
<tr>
<td>pp 或 p</td>
<td>打印变量的值</td>
</tr>
<tr>
<td>help</td>
<td>帮助</td>
</tr>
</tbody>
</table>
<h3 id="Openstack代码调试"><a href="#Openstack代码调试" class="headerlink" title="Openstack代码调试"></a>Openstack代码调试</h3><p>首先需要找到需要调试代码的位置，下面通过一个虚拟机创建的例子来说明。</p>
<ol>
<li>首先找到代码的位置；<code>Openstack</code>的代码一般在<code>/usr/lib/python2.7/site-packages/</code>目录下；</li>
<li>在代码的入口处添加断点，<code>import pdb; pdb.set_trace()</code>；</li>
<li>一般<code>Openstack</code>的服务都是有<code>systemd</code>管理，所以需要使用<code>systemctl</code>停掉对应的服务；</li>
<li>重新启动对应的服务，此时不能够再使用<code>systemctl</code>的方式去启动，需要直接使用运行源码的方式去运行，比如<code>nova-compute</code>服务，使用<code>/usr/bin/nova-compute</code>进行启动。</li>
</ol>
<p>接下来就可以进行调试了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍Openstack的代码调试之前，先熟悉下在Python中是如何进行代码调试的。&lt;br&gt;
    
    </summary>
    
    
      <category term="openstack" scheme="http://yoursite.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python 的 with 语句</title>
    <link href="http://yoursite.com/2017/12/07/python-with/"/>
    <id>http://yoursite.com/2017/12/07/python-with/</id>
    <published>2017-12-07T11:16:14.000Z</published>
    <updated>2017-12-07T11:18:02.519Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读<code>openstack</code>的源码过程中，会在很多地方看到<code>with</code>关键字，接下来就谈谈<code>python</code>中如何使用<code>with</code>关键字。<br><a id="more"></a></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>with</code>语句是从<code>Python 2.5</code>开始引入的一种与异常处理相关的功能，<code>with</code>语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>要使用<code>with</code>语句，首先要明白上下文管理器这一概念。有了上下文管理器，<code>with</code>语句才能工作。<br>下面是一组与上下文管理器和<code>with</code>语句有关的概念。</p>
<ul>
<li>上下文管理协议（Context Management Protocol）：包含方法<code>__enter__()</code>和<code>__exit__()</code>，支持该协议的对象要实现这两个方法。</li>
<li>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<code>__enter__()</code>和<code>__exit__()</code>方法。上下文管理器定义执行<code>with</code>语句时要建立的运行时上下文，负责执行<code>with</code>语句块上下文中的进入与退出操作。通常使用<code>with</code>语句调用上下文管理器，<br>也可以通过直接调用其方法来使用。</li>
<li>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的<code>__enter__()</code>和<code>__exit__()</code>方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code>在语句体执行完后从运行时上下文退出。<code>with</code>语句支持运行时上下文这一概念。</li>
<li>上下文表达式（Context Expression）：<code>with</code>语句中跟在关键字<code>with</code>之后的表达式，该表达式要返回一个上下文管理器对象。</li>
<li>语句体（with-body）：<code>with</code>语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的<code>__enter__()</code>方法，执行完语句体之后会执行<code>__exit__()</code>方法。</li>
</ul>
<h3 id="基本语法和工作原理"><a href="#基本语法和工作原理" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p><code>with</code>语句的语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with context_expression [as target(s)]:</div><div class="line">    with-body</div></pre></td></tr></table></figure></p>
<p>这里<code>context_expression</code>要返回一个上下文管理器对象，该对象并不赋值给<code>as</code>子句中的<code>target(s)</code>，如果指定了<code>as</code>子句的话，会将上下文管理器的<code>__enter__()</code>方法的返回值赋值给<code>target(s)</code>。<code>target(s)</code>可以是单个变量，或者由<code>()</code>括起来的元组（不能是仅仅由<code>,</code>分隔的变量列表，必须加<code>()</code>）。</p>
<p><code>Python</code>对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于<code>with</code>语句中，比如开发过程中经常使用到的读写文件、线程锁的自动获取和释放等。</p>
<p>下面使用一个文件读写的例子来看看使用和不使用with的写法。<br>使用<code>with</code>的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with open(&apos;fileName&apos;, w+) as somefile:</div><div class="line">    somefile.write(&apos;Hello World&apos;)</div></pre></td></tr></table></figure></p>
<p>不使用<code>with</code>的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    f = open(&apos;filename.log&apos;, &apos;w+&apos;)</div><div class="line">    f.write(&apos;Hello World&apos;)</div><div class="line">finally:</div><div class="line">        f.close()</div></pre></td></tr></table></figure></p>
<p>通过比较这两种写法，可以看出使用<code>with</code>可以减少代码量，并且使代码更加清晰。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="external">PEP 0343</a>对<code>with</code>语句的实现进行了描述。<code>with</code>语句的执行过程类似如下代码块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">context_manager = context_expression</div><div class="line">exit = type(context_manager).__exit__  </div><div class="line">value = type(context_manager).__enter__(context_manager)</div><div class="line">exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</div><div class="line">try:</div><div class="line">    try:</div><div class="line">        target = value  # 如果使用了 as 子句</div><div class="line">        with-body     # 执行 with-body</div><div class="line">    except:</div><div class="line">        # 执行过程中有异常发生</div><div class="line">        exc = False</div><div class="line">        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</div><div class="line">        # 由外层代码对异常进行处理</div><div class="line">        if not exit(context_manager, *sys.exc_info()):</div><div class="line">            raise</div><div class="line">finally:</div><div class="line">    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</div><div class="line">    # 或者忽略异常退出</div><div class="line">    if exc:</div><div class="line">        exit(context_manager, None, None, None) </div><div class="line">    # 缺省返回 None，None 在布尔上下文中看做是 False</div></pre></td></tr></table></figure></p>
<ol>
<li>执行<code>context_expression</code>，生成上下文管理器<code>context_manager</code></li>
<li>调用上下文管理器的<code>__enter__()</code>方法；如果使用了<code>as</code>子句，则将<code>__enter__()</code>方法的返回值赋值给<code>as</code>子句中的<code>target(s)</code></li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的<code>__exit__()</code>方法，<code>__exit__()</code>方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句<code>break/continue/return</code>，则以<code>None</code>作为参数调用<code>__exit__(None, None, None)</code>；如果执行过程中出现异常，则使用<code>sys.exc_info</code>得到的异常信息为参数调用<code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果<code>__exit__(type, value, traceback)</code>返回<code>False</code>，则会重新抛出异常，让<code>with</code>之外的语句逻辑来处理异常，这也是通用做法；如果返回<code>True</code>，则忽略异常，不再对异常进行处理。</li>
</ol>
<h3 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h3><p>开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的<code>__enter__()</code>和<code>__exit__()</code>两个方法：</p>
<ul>
<li><code>context_manager.__enter__()</code>：进入上下文管理器的运行时上下文，在语句体执行前调用。<code>with</code>语句将该方法的返回值赋值给<code>as</code>子句中的<code>target</code>(如果指定了<code>as</code>子句的)</li>
<li><code>context_manager.__exit__(exc_type, exc_value, exc_traceback)</code>：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为<code>None</code>。如果发生异常，返回<code>True</code>表示不处理异常，否则会在退出该方法后重新抛出异常，以由<code>with</code>语句之外的代码逻辑进行处理。<strong>如果该方法内部产生异常，则会取代由<code>statement-body</code>中语句产生的异常</strong>。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为<code>False</code>就可以了。之后，上下文管理代码会检测是否<code>__exit__()</code>失败来处理异常。</li>
</ul>
<p>下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供<code>__enter__()</code>和<code>__exit__()</code>方法的定义，缺少任何一个都会导致<code>AttributeError</code>；<code>with</code>语句会先检查是否提供了<code>__exit__()</code>方法，然后检查是否定义了<code>__enter__()</code>方法。</p>
<p>假设有一个资源<code>DummyResource</code>，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到<code>__enter__()</code>方法中，释放操作可以放到<code>__exit__()</code>方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class DummyResource:</div><div class="line">    def __init__(self, tag):</div><div class="line">        self.tag = tag</div><div class="line">        print &apos;Resource [%s]&apos; % tag</div><div class="line">    def __enter__(self):</div><div class="line">        print &apos;[Enter %s]: Allocate resource.&apos; % self.tag</div><div class="line">        return self   # 可以返回不同的对象</div><div class="line">    def __exit__(self, exc_type, exc_value, exc_tb):</div><div class="line">        print &apos;[Exit %s]: Free resource.&apos; % self.tag</div><div class="line">        if exc_tb is None:</div><div class="line">            print &apos;[Exit %s]: Exited without exception.&apos; % self.tag</div><div class="line">        else:</div><div class="line">            print &apos;[Exit %s]: Exited with exception raised.&apos; % self.tag</div><div class="line">            return False   # 可以省略，缺省的None也是被看做是False</div></pre></td></tr></table></figure>
<p><code>DummyResource</code>中的<code>__enter__()</code>返回的是自身的引用，这个引用可以赋值给<code>as</code>子句中的<code>target</code>变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。</p>
<p><code>__exit__()</code>方法中对变量<code>exc_tb</code>进行检测，如果不为<code>None</code>，表示发生了异常，返回<code>False</code>表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为<code>None</code>，在布尔环境中也是被看做<code>False</code>，但是由于没有异常发生，<code>__exit__()</code>的三个参数都为<code>None</code>，上下文管理代码可以检测这种情况，做正常处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">with DummyResource(&apos;Normal&apos;):</div><div class="line">    print &apos;[with-body] Run without exceptions.&apos;</div><div class="line"> </div><div class="line">try:</div><div class="line">    with DummyResource(&apos;With-Exception&apos;):</div><div class="line">        print &apos;[with-body] Run with exception.&apos;</div><div class="line">        raise Exception</div><div class="line">    except Exception:</div><div class="line">        print &apos;[with-body] Run with exception. Failed to finish statement-body!&apos;</div><div class="line">        raise Exception</div></pre></td></tr></table></figure>
<p>第一个<code>with</code>语句执行的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Resource [Normal]</div><div class="line">[Enter Normal]: Allocate resource.</div><div class="line">[with-body] Run without exceptions.</div><div class="line">[Exit Normal]: Free resource.</div><div class="line">[Exit Normal]: Exited without exception.</div></pre></td></tr></table></figure></p>
<p>可以看出执行完<code>with body</code>之后会执行<code>__exit__()</code>释放资源。</p>
<p>第2个 with 语句的执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Resource [With-Exception]</div><div class="line">[Enter With-Exception]: Allocate resource.</div><div class="line">[with-body] Run with exception.</div><div class="line">[Exit With-Exception]: Free resource.</div><div class="line">[Exit With-Exception]: Exited with exception raised.</div><div class="line">[with-body] Run with exception. Failed to finish statement-body!</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;python_20171204.py&quot;, line 40, in &lt;module&gt;</div><div class="line">    raise Exception</div><div class="line">Exception</div></pre></td></tr></table></figure></p>
<p>当你在<code>with-body</code>中抛出异常时，会执行上下文管理器的<code>__exit__</code>方法，并且该方法的三个参数均不为空，返回<code>False</code>之后会由外部代码逻辑对异常进行处理。</p>
<p>可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。</p>
<p>转自：<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="external">浅谈Python的with语句</a></p>
<p><strong>告侵删</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读&lt;code&gt;openstack&lt;/code&gt;的源码过程中，会在很多地方看到&lt;code&gt;with&lt;/code&gt;关键字，接下来就谈谈&lt;code&gt;python&lt;/code&gt;中如何使用&lt;code&gt;with&lt;/code&gt;关键字。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之强大的装饰器</title>
    <link href="http://yoursite.com/2017/12/01/python-function-decorator/"/>
    <id>http://yoursite.com/2017/12/01/python-function-decorator/</id>
    <published>2017-12-01T11:41:37.000Z</published>
    <updated>2017-12-01T11:47:17.526Z</updated>
    
    <content type="html"><![CDATA[<p>Python有大量强大又贴心的特性，如果要列个最受欢迎排行榜，那么装饰器绝对会在其中。</p>
<p>刚接触装饰器，会觉得代码不多却难以理解。其实装饰器的语法本身挺简单的，复杂是因为同时混杂了其它的概念。下面我们一起抛去无关概念，简单地理解下Python的装饰器。本文只会讲解函数装饰器而不牵涉到类装饰器。<br><a id="more"></a></p>
<h3 id="装饰器的原理"><a href="#装饰器的原理" class="headerlink" title="装饰器的原理"></a>装饰器的原理</h3><p>通过一个例子直观的感受下<code>python</code>的装饰器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;hello world&apos;)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line"></div><div class="line">@log</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div></pre></td></tr></table></figure></p>
<p><code>log</code>就是一个装饰器。被<code>log</code>装饰的<code>now</code>，执行<code>now()</code>方法时都会打印<code>hello world</code>。</p>
<h3 id="理解装饰器的准备工作"><a href="#理解装饰器的准备工作" class="headerlink" title="理解装饰器的准备工作"></a>理解装饰器的准备工作</h3><p>接下来我们分成三部分来做准备工作。</p>
<h4 id="函数亦是对象"><a href="#函数亦是对象" class="headerlink" title="函数亦是对象"></a>函数亦是对象</h4><p>在<code>python</code>中<code>万物</code>皆是对象，当然这的<code>万物</code>自然也包括函数了。</p>
<p>我们定义个<code>print_str</code>函数。这时<code>print_str</code>也是个对象，它能做所有对象的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def print_str():</div><div class="line">    return &apos;hello world&apos;</div></pre></td></tr></table></figure>
<p>所有对象都有三种特性: id、类型、值。接下来就看看函数是否有这三种特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id(print_str)</div><div class="line">139764090382048</div><div class="line">type(print_str)</div><div class="line">&lt;type &apos;function&apos;&gt;</div><div class="line">print_str</div><div class="line">&lt;function print_str at 0x7f1d5cf5a6e0&gt;</div></pre></td></tr></table></figure></p>
<p>所以函数也是对象，跟其他对象一样也可以被赋值给其它变量。同时可以当参数传递，也可以当返回值。</p>
<h4 id="是个语法糖"><a href="#是个语法糖" class="headerlink" title="@是个语法糖"></a>@是个语法糖</h4><p>装饰器的@没有做什么特别的事，不用它也可以实现一样的功能，只不过需要更多的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@log</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div></pre></td></tr></table></figure></p>
<p>上面的代码等价于下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div><div class="line">now = log(now)</div></pre></td></tr></table></figure></p>
<p><code>log</code>是个函数，它要求入参是函数对象，返回值是函数对象。<code>@</code>的语法糖其实是省去了上面最后一行代码，使可读性更好。用了装饰器后，每次调用<code>now</code>，真正调用的是<code>log</code>返回的函数对象。</p>
<h4 id="嵌套函数和闭包"><a href="#嵌套函数和闭包" class="headerlink" title="嵌套函数和闭包"></a>嵌套函数和闭包</h4><p>Python的函数可以嵌套定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def outer():</div><div class="line">    print(&apos;Before def:&apos;, locals())</div><div class="line">    def inner():</div><div class="line">        pass</div><div class="line">    print(&apos;After def:&apos;, locals())</div><div class="line">    return inner</div></pre></td></tr></table></figure>
<p><code>inner</code>是在<code>outer</code>内定义的，所以算<code>outer</code>的局部变量。执行到<code>def inner</code>时函数对象才创建，因此每次调用<code>outer</code>都会创建一个新的<code>inner</code>。下面可以看出，每次返回的<code>inner</code>是不同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">outer()</div><div class="line">Before def: &#123;&#125;</div><div class="line">After def: &#123;&apos;inner&apos;: &lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa0048&gt;&#125;</div><div class="line">&lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa0048&gt;</div><div class="line"></div><div class="line">outer()</div><div class="line">Before def: &#123;&#125;</div><div class="line">After def: &#123;&apos;inner&apos;: &lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa00d0&gt;&#125;</div><div class="line">&lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa00d0&gt;</div></pre></td></tr></table></figure></p>
<p>说到嵌套函数就不得不提闭包，在这里只说下闭包的两个特点：</p>
<ol>
<li><code>inner</code>能访问<code>outer</code>及其祖先函数的命名空间内的变量(局部变量，函数参数)。</li>
<li>调用<code>outer</code>已经返回了，但是它的命名空间被返回的<code>inner</code>对象引用，所以还不会被回收。</li>
</ol>
<h3 id="用函数实现装饰器"><a href="#用函数实现装饰器" class="headerlink" title="用函数实现装饰器"></a>用函数实现装饰器</h3><p>装饰器要求入参是函数对象，返回值是函数对象，嵌套函数完全能胜任。</p>
<p>这里我们还是使用上边的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;hello world&apos;)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line"></div><div class="line">@log</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div><div class="line">    </div><div class="line">now()</div></pre></td></tr></table></figure></p>
<p>注意：因为返回的<code>wrapper</code>还在引用着，所以存在于<code>log</code>命名空间的<code>func</code>不会消失。<code>log</code>可以装饰多个函数，<code>wrapper</code>不会调用混淆，因为每次调用<code>log</code>，都会有创建新的命名空间和新的<code>wrapper</code>。</p>
<h3 id="实现带参数的装饰器？"><a href="#实现带参数的装饰器？" class="headerlink" title="实现带参数的装饰器？"></a>实现带参数的装饰器？</h3><p>带参数的装饰器，有时会异常的好用。我们看个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@log(&apos;DEBUG&apos;)</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div><div class="line"></div><div class="line">now()</div><div class="line">DEBUG: hello world</div><div class="line">2015-3-25</div></pre></td></tr></table></figure></p>
<p>怎么做到的呢？其实这跟装饰器语法没什么关系。去掉@语法糖会变得很容易理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@log(&apos;DEBUG&apos;)</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div><div class="line">unnamed_decorator = log(&apos;DEBUG&apos;)</div><div class="line">now = unnamed_decorator(now)</div></pre></td></tr></table></figure></p>
<p>上面代码中的<code>unnamed_decorator</code>才是真正的装饰器，<code>log</code>是个普通的函数，它的返回值是装饰器。</p>
<p>来看一下具体实现的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def log(level):</div><div class="line">    print(&apos;Create decorator&apos;)</div><div class="line"></div><div class="line">    # 这部分跟通常的装饰器一样，只是wrapper通过闭包访问了变量level</div><div class="line">    def decorator(func):</div><div class="line">        print(&apos;Initialize&apos;)</div><div class="line"></div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print(&apos;%s: Hellow World&apos; % level)</div><div class="line">        return wrapper</div><div class="line">    # log 返回装饰器</div><div class="line">    return decorator</div></pre></td></tr></table></figure></p>
<h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h3><p>Python的装饰器倍感贴心的地方是对调用方透明。调用方完全不知道也不需要知道调用的函数被装饰了。这样我们就能在调用方的代码完全不改动的前提下，给函数patch功能，重要的事情讲三遍：patch，patch，patch。</p>
<p>为了对调用方透明，装饰器返回的对象要伪装成被装饰的函数。伪装得越像，对调用方来说差异越小。有时光伪装函数名和参数是不够的，因为<code>Python</code>的函数对象有一些元信息调用方可能读取了。为了连这些元信息也伪装上，<code>functools.wraps</code>出场了。它能用于把被调用函数的<code>__module__</code>，<code>__name__</code>，<code>__qualname__</code>，<code>__doc__</code>，<code>__annotations__</code>赋值给装饰器返回的函数对象。</p>
<p>使用<code>functools.wraps</code>的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;hello world&apos;)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure></p>
<p>不使用<code>functools.wraps</code>的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def log(func):</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;hello world&apos;)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure></p>
<p>对比一下效果两种情况的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@log</div><div class="line">def now():</div><div class="line">    print(&apos;2015-3-25&apos;)</div></pre></td></tr></table></figure></p>
<p>不用functools.wraps的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">now.__name__</div><div class="line"></div><div class="line">&apos;wrapper&apos;</div></pre></td></tr></table></figure></p>
<p>用functools.wraps的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">now.__name__</div><div class="line"></div><div class="line">&apos;now&apos;</div></pre></td></tr></table></figure></p>
<p>很明显，结果一目了然。实现装饰器时往往不知道调用方会怎么用，所以养成好习惯加上<code>functools.wraps</code>吧。</p>
<p>传送门：<a href="http://www.lightxue.com/understand-python-decorator-the-easy-way" target="_blank" rel="external">简单地理解 Python 的装饰器</a><br>告侵删。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python有大量强大又贴心的特性，如果要列个最受欢迎排行榜，那么装饰器绝对会在其中。&lt;/p&gt;
&lt;p&gt;刚接触装饰器，会觉得代码不多却难以理解。其实装饰器的语法本身挺简单的，复杂是因为同时混杂了其它的概念。下面我们一起抛去无关概念，简单地理解下Python的装饰器。本文只会讲解函数装饰器而不牵涉到类装饰器。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>简单的几个python内置函数</title>
    <link href="http://yoursite.com/2017/11/29/python-internal-functions/"/>
    <id>http://yoursite.com/2017/11/29/python-internal-functions/</id>
    <published>2017-11-29T11:30:05.000Z</published>
    <updated>2017-11-29T11:33:29.643Z</updated>
    
    <content type="html"><![CDATA[<p>几个简单的python内置函数的介绍，以及应用。对于开发来说，这些简单的函数有时候会如虎添翼。<br><a id="more"></a></p>
<h3 id="map函数："><a href="#map函数：" class="headerlink" title="map函数："></a>map函数：</h3><p>map函数：<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map(function, Iterable)</div></pre></td></tr></table></figure></p>
<p>简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">def fun(a):</div><div class="line">    return math.pow(a,2)</div><div class="line"></div><div class="line">list(map(fun,range(3)))</div></pre></td></tr></table></figure></p>
<h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce函数：<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reduce(function, Iterable)</div></pre></td></tr></table></figure></p>
<p>简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from functools import reduce</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">    </div><div class="line">reduce(add, [1, 3, 5, 7, 9])</div></pre></td></tr></table></figure></p>
<h3 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h3><p>filter函数：<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filter(function, Iterable)</div></pre></td></tr></table></figure></p>
<p>简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def is_odd(n):</div><div class="line">    return n % 2 == 1</div><div class="line"></div><div class="line">list(filter(is_odd,[1,2,3,4,5,6,7,8,9]))</div></pre></td></tr></table></figure></p>
<p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p>
<h3 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h3><p>sorted函数：排序。它还可以接收一个key函数来实现自定义的排序。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sorted(iterable, key=None, reverse=False)</div></pre></td></tr></table></figure></p>
<ul>
<li><code>iterable</code>：待排序的可迭代类型的容器。</li>
<li><code>cmp</code>：比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li>
<li><code>key</code>：主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li><code>reverse</code>：排序规则。<code>reverse = True</code>或者 <code>reverse = False</code>，默认值为<code>false</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">args = [0.3, 1, -3, 2]</div><div class="line">results = sorted(args, key=lambda x: x*x, reverse=True)</div><div class="line"></div><div class="line">[-3, 2, 1, 0.3]</div><div class="line"></div><div class="line">args = [(&apos;John&apos;, &apos;A&apos;, 15), (&apos;Smith&apos;, &apos;B&apos;, 12), (&apos;Dave&apos;, &apos;C&apos;, 10)]</div><div class="line"># 按照成绩排名</div><div class="line">sorted(args, cmp=lambda x,y:cmp(x[1],y[1]))</div><div class="line"></div><div class="line">[(&apos;John&apos;, &apos;A&apos;, 15), (&apos;Smith&apos;, &apos;B&apos;, 12), (&apos;Dave&apos;, &apos;C&apos;, 10)]</div><div class="line"># 按照年龄排名</div><div class="line">sorted(args, key=lambda x:x[2])</div><div class="line"></div><div class="line">[(&apos;Dave&apos;, &apos;C&apos;, 10), (&apos;Smith&apos;, &apos;B&apos;, 12), (&apos;John&apos;, &apos;A&apos;, 15)]</div><div class="line"></div><div class="line"># 按照姓氏排名</div><div class="line">sorted(args, cmp=lambda x,y:cmp(x[1],y[1]))</div><div class="line"></div><div class="line">[(&apos;Dave&apos;, &apos;C&apos;, 10), (&apos;John&apos;, &apos;A&apos;, 15), (&apos;Smith&apos;, &apos;B&apos;, 12)]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h3><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>关键字lambda表示匿名函数。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lambda arguments: expression</div></pre></td></tr></table></figure></p>
<ul>
<li><code>lambda</code>：定义匿名函数的关键字</li>
<li><code>arguments</code>：函数的参数列表，参数之间用逗号<code>（,）</code>分割。</li>
<li><code>expression</code>：被返回的表达式，且表达式只能有一个（注意： <code>lambda</code>定义不包含<code>return</code>语句），不用写return，返回值就是该表达式的结果。</li>
</ul>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = lambda x,y: x * y</div><div class="line">f(5,6)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个简单的python内置函数的介绍，以及应用。对于开发来说，这些简单的函数有时候会如虎添翼。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>我们原本不该是这样</title>
    <link href="http://yoursite.com/2017/11/27/we-should-not-have-been-this-way/"/>
    <id>http://yoursite.com/2017/11/27/we-should-not-have-been-this-way/</id>
    <published>2017-11-27T14:54:46.000Z</published>
    <updated>2017-11-29T04:50:13.155Z</updated>
    
    <content type="html"><![CDATA[<p>早已经习惯了每天朝九晚五的生活，习惯了每天乘坐拥挤的地铁，习惯了每天满腹牢骚，习惯了每天义愤填膺，习惯了每天憧憬明天。<br><a id="more"></a><br>从两个小故事说起。</p>
<p>第一个小故事，带你了解一下所谓的“乾隆盛世”：</p>
<p>1793年，乾隆五十八年夏天，英国派出第一个访华使团到达中国。在使团出发之前，英国人对这个神秘的东方国度充满好奇，他们相信，中国就像《马可波罗游记》中所写的那样，黄金满地，人人都穿着绫罗绸缎。</p>
<p>在使团到达浙江沿海后因为不熟悉中国航线，英国人要求当地总兵帮他们找一个领航员。总兵痛快的答应了。</p>
<p>但是接下来发生的一幕，大大超乎了英国人的想象：总兵派出士兵，把所有从海路去过天津的百姓都找来了。使团成员巴罗说：“他们派出的兵丁很快带回了一群人。他们是我平生所见神情最悲惨的家伙了，一个个双膝跪地，接受询问……他们徒劳地哀告道，离家远行会坏了他们的生意，给妻子儿女和家庭带来痛苦。总兵依然不为所动，命令他们一小时后准本妥当。”</p>
<p>这仅仅是英国人一连串吃惊的开始，比这更让他们震惊的事还在后面。</p>
<p>在船只行驶位于内河时，英国人注意到，官员们强征大批百姓来拉纤，拉一天“约有六便士的工资”，但是不给回家的路费。这显然是不合算的，许多人并不想要这份工资，不断有逃亡的情况发生。“为了找到替手，官员们派手下的兵丁去附近的村庄，出其不意地把一些村民从床上拉起来加入民夫队。兵丁鞭打试图逃跑或以年老体弱为由要求免役的民夫的事，几乎没有一夜不发生。看到他们当中一些人的悲惨状况，真令人痛苦。他们明显地缺衣少食，瘦弱不堪……他们总是被兵丁或什么小官吏的随从监督着。监工们手中的长鞭会毫不犹豫地抽向他们的身子，仿佛他们就是一队马匹似的。”</p>
<p><strong>忘记历史，就是在重蹈覆辙。</strong></p>
<p>我们以前是这样的。从来我们都是习惯于安逸，习惯于顺从，习惯于被统治。二十多年历史的空洞，让我丧失了底线，丧失了传统，丧失了人与人之间的信任，这段历史带给我们民族的损坏是毁灭性的打击，从此我们朝着不同的方向在大踏步的前进。今天，我们早已适应了顺从，习惯了窝里横，没有了道德底线，变的易怒，盛世凌人。</p>
<p>第二个小故事，带你认识台湾：</p>
<p>台湾，一个现在已经不太敏感的话题，一个没有经过文化大革命的“中国”，一个彰显中国传统文化的地方（至少我是这样认为的）。</p>
<p>在台北，很少有汽车鸣笛。仅容一车可以通过的巷子里，行人往往走了很久，猛然回头才发现有一辆客气的车默默跟在后面。地铁里顺序上下，不会有人蓄势待发如虎，稍有空隙就推开别人往前冲。在这里，一旦出现空位子，站在附近的人们相互微笑谦让，才会有一个稍带歉意的坐下。不小心被背包扫到，立刻就会有人说：对不起。但这种客气又并非虚伪，无论是路过行人，还是“名人”，他们说话都会看着你的眼睛，真诚，信任。</p>
<p>公共汽车上，每个人在刷卡下车时，都对司机说，谢谢。</p>
<p>台北是一座与人和善的城市。小小的街道，处处是便利店，小吃店。台大附近的巷弄里，遍地是咖啡馆，书店。人们在此恋爱，写作，高谈阔论，用最美好的方式打发时光。</p>
<p>也许这才应该是我们的今天。温良恭俭让。</p>
<p>历史的真相永远不应该被淹没，被歪曲。作为一个拥有独立思考能力并且直立行走的，并且渴望挣脱束缚的青年，有责任也有义务去记录了解真相，而不是去选择相信道听途说，甚至意气用事，被别人玩弄于鼓掌之中而不自知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早已经习惯了每天朝九晚五的生活，习惯了每天乘坐拥挤的地铁，习惯了每天满腹牢骚，习惯了每天义愤填膺，习惯了每天憧憬明天。&lt;br&gt;
    
    </summary>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>理解 Python 中的 *args 和 **kw</title>
    <link href="http://yoursite.com/2017/11/24/python-args-kw/"/>
    <id>http://yoursite.com/2017/11/24/python-args-kw/</id>
    <published>2017-11-24T07:26:59.000Z</published>
    <updated>2017-11-29T04:49:50.300Z</updated>
    
    <content type="html"><![CDATA[<p>反复在Python的函数声明中见到<code>*args</code>和<code>**kw</code>，对其作用非常模糊，所以特作整理。<br><a id="more"></a><br>Python是支持可变参数的，最简单的方法莫过于使用默认参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def test_defargs(one, two = 2):</div><div class="line">   print &apos;Required argument: &apos;, one</div><div class="line">   print &apos;Optional argument: &apos;, two</div><div class="line"></div><div class="line">test_defargs(1)</div><div class="line"># result:</div><div class="line"># Required argument: 1</div><div class="line"># Optional argument: 2</div><div class="line"></div><div class="line">test_defargs(1, 3)</div><div class="line"># result:</div><div class="line"># Required argument: 1</div><div class="line"># Optional argument: 3</div></pre></td></tr></table></figure></p>
<p>当然，本文章的主题并不是讲默认参数，而是另外一种达到可变参数 (Variable Argument) 的方法：使用<code>*args</code>和<code>**kw</code>语法。其中，<code>*args</code>是可变的positional arguments列表，<code>**kw</code>是可变的keyword arguments列表。并且，<code>*args</code>必须位于<code>**kw</code>之前，因为positional arguments必须位于keyword arguments之前。</p>
<p>首先介绍两者的基本用法。</p>
<p>下面一个例子使用*args，同时包含一个必须的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def test_args(first, *args):</div><div class="line">   print &apos;Required argument: &apos;, first</div><div class="line">   for v in args:</div><div class="line">      print &apos;Optional argument: &apos;, v</div><div class="line"></div><div class="line">test_args(1, 2, 3, 4)</div><div class="line"># result:</div><div class="line"># Required argument: 1</div><div class="line"># Optional argument:  2</div><div class="line"># Optional argument:  3</div><div class="line"># Optional argument:  4</div></pre></td></tr></table></figure></p>
<p>下面一个例子使用<code>**kw</code>, 同时包含一个必须的参数和<code>*args</code>列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def test_kw(first, *args, **kw):</div><div class="line">   print &apos;Required argument: &apos;, first</div><div class="line">   for v in args:</div><div class="line">      print &apos;Optional argument (*args): &apos;, v</div><div class="line">   for k, v in kw.items():</div><div class="line">      print &apos;Optional argument %s (*kw): %s&apos; % (k, v)</div><div class="line"></div><div class="line">test_kw(1, 2, 3, 4, k1=5, k2=6)</div><div class="line"># results:</div><div class="line"># Required argument:  1</div><div class="line"># Optional argument (*args):  2</div><div class="line"># Optional argument (*args):  3</div><div class="line"># Optional argument (*args):  4</div><div class="line"># Optional argument k2 (*kw): 6</div><div class="line"># Optional argument k1 (*kw): 5</div></pre></td></tr></table></figure></p>
<p><code>*args</code>和<code>**kw</code>语法不仅可以在函数定义中使用，同样可以在函数调用的时候使用。不同的是，如果说在函数定义的位置使用<code>*args</code>和<code>**kw</code>是一个将参数<code>pack</code>的过程，那么在函数调用的时候就是一个将参数<code>unpack</code>的过程了。下面使用一个例子来加深理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">def test_args(first, second, third, fourth, fifth):</div><div class="line">    print &apos;First argument: &apos;, first</div><div class="line">    print &apos;Second argument: &apos;, second</div><div class="line">    print &apos;Third argument: &apos;, third</div><div class="line">    print &apos;Fourth argument: &apos;, fourth</div><div class="line">    print &apos;Fifth argument: &apos;, fifth</div><div class="line"></div><div class="line"># Use *args</div><div class="line">args = [1, 2, 3, 4, 5]</div><div class="line">test_args(*args)</div><div class="line"># results:</div><div class="line"># First argument:  1</div><div class="line"># Second argument:  2</div><div class="line"># Third argument:  3</div><div class="line"># Fourth argument:  4</div><div class="line"># Fifth argument:  5</div><div class="line"></div><div class="line"># Use **kw</div><div class="line">kw = &#123;</div><div class="line">    &apos;first&apos;: 1,</div><div class="line">    &apos;second&apos;: 2,</div><div class="line">    &apos;third&apos;: 3,</div><div class="line">    &apos;fourth&apos;: 4,</div><div class="line">    &apos;fifth&apos;: 5</div><div class="line">&#125;</div><div class="line"></div><div class="line">test_args(**kw)</div><div class="line"># results:</div><div class="line"># First argument:  1</div><div class="line"># Second argument:  2</div><div class="line"># Third argument:  3</div><div class="line"># Fourth argument:  4</div><div class="line"># Fifth argument:  5</div></pre></td></tr></table></figure></p>
<p>使用<code>*args</code>和<code>**kw</code>可以非常方便的定义函数，同时可以加强扩展性，以便日后的代码维护。</p>
<p>文章转自：<a href="http://kodango.com/variable-arguments-in-python" target="_blank" rel="external">理解 Python 中的<em>args和*</em>kw</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反复在Python的函数声明中见到&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kw&lt;/code&gt;，对其作用非常模糊，所以特作整理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Openstack创建虚机流程</title>
    <link href="http://yoursite.com/2017/10/31/openstack-boot-instance/"/>
    <id>http://yoursite.com/2017/10/31/openstack-boot-instance/</id>
    <published>2017-10-31T09:47:12.000Z</published>
    <updated>2017-12-20T02:38:18.441Z</updated>
    
    <content type="html"><![CDATA[<p>openstack在创建虚机的过程中nova的每个服务都扮演了什么角色，以及它们是如何协作的？</p>
<a id="more"></a>
<h3 id="nova组件的子服务"><a href="#nova组件的子服务" class="headerlink" title="nova组件的子服务"></a>nova组件的子服务</h3><p>nova中的各个子服务介绍：</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nova-api</td>
<td>接收并相应用户的请求，执行一些策略，并且发起一些流程，比如：启动一个虚机</td>
</tr>
<tr>
<td>nova-conductor</td>
<td>中间层，用于nova-compute和database之间的互动，消除了nova-compute服务对数据库的直接访问</td>
</tr>
<tr>
<td>nova-scheduler</td>
<td>从消息队列中获取一个虚机的请求，然后决定在哪个计算节点执行</td>
</tr>
<tr>
<td>nova-compute</td>
<td>nova组件中最核心的服务，通过调用hypervisor API实现了虚机的管理功能。比如：虚机的创建，重启，关闭，删除等操作。</td>
</tr>
<tr>
<td>nova-consoleauth</td>
<td>为控制台代理提供用户的身份令牌。</td>
</tr>
<tr>
<td>nova-vpcproxy</td>
<td>提供了一个通过VNC连接正在运行的虚机的代理。</td>
</tr>
</tbody>
</table>
<p>其中每个服务都有以下一个文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>api.py</td>
<td>供其他组件进行调用</td>
</tr>
<tr>
<td>rpcapi.py</td>
<td>RPC请求的封装，或者可以这样理解，RPC实现的client端</td>
</tr>
<tr>
<td>manager.py</td>
<td>服务的实现，RPC的server端</td>
</tr>
</tbody>
</table>
<h3 id="nova创建虚机的流程"><a href="#nova创建虚机的流程" class="headerlink" title="nova创建虚机的流程"></a>nova创建虚机的流程</h3><p>创建虚机的流程图：<br><img src="http://ot8956ufo.bkt.clouddn.com/request-flow-for-provisioning-instance-in-openstack.png" alt=""></p>
<p>创建虚机流程如下:</p>
<ol>
<li>通过Dashboard或者command-line获取用户凭据，然后通过RESTful API调用keystone进行身份验证；</li>
<li>keystone对用户凭据进行认证并且生成和发送auth-token信息，以便其它组件之间通过REST-call方式发送请求时使用auth-token信息；</li>
<li>Dashboard或者command-line将‘launch instance’或者‘nova-boot’的请求转化为一个REST API请求，并且发送给nova-api；</li>
<li>nova-api接收到这个请求后，向keystone发送请求验证auth-token和访问权限；</li>
<li>keystone验证token是否有效，如果有效，更新auth的头部信息，包括角色和权限，并且返回；</li>
<li>nova-api与数据库进行通讯；</li>
<li>对新建的虚拟机在数据库中初始化一条记录；</li>
<li>nova-api向nova-scheduler发送RPC同步调用请求；</li>
<li>nova-scheduler从消息队列中监听到该请求；</li>
<li>nova-scheduler通过查询数据库计算资源的使用情况，并且通过调度算法，筛选出创建虚机使用的物理机；</li>
<li>返回更新后的该虚拟机对应的数据库的记录，此次主要更新虚机对应的物理机的信息；</li>
<li>nova-scheduler向指定物理机的nova-compute发送创建虚机的RPC异步请求，这里指定的物理机指的是第10步中筛选出的物理机</li>
<li>nova-compute从消息队列中监听到该请求；</li>
<li>nova-compute向nova-conductor发送RPC同步调用，更新虚机的信息，比如：物理机ID和规格（内存，CPU，硬盘）等信息</li>
<li>nova-condutor从消息队列中监听到该请求；</li>
<li>nova-conudctor更新该虚机对应的数据库记录；</li>
<li>nova-conductor向nova-compute发送RPC异步调用，发送内容包括该虚机的信息</li>
<li>nova-compute从消息队列中监听到该请求，并且获取到该虚机的信息；</li>
<li>nova-compute通过auth-token访问glance-api服务，通过镜像ID获取镜像的URI，然后从镜像存储服务器上下载该镜像；</li>
<li>glance-api调用keystone验证auth-toker信息；</li>
<li>验证通过后，nova-compute获取镜像的元数据；</li>
<li>nova-cmpute使用auth-toker访问Network API,给虚机分配和配置网络信息，例如：虚机的IP地址； </li>
<li>quantum-server调用keystone验证auth-token;</li>
<li>验证通过后，nova-compute获取到网络信息；</li>
<li>同样的，nova-cmpute使用auth-toker访问Volume API，给虚机绑定云硬盘；</li>
<li>cinder-api调用keystone验证auth-token</li>
<li>nova-compute获取云硬盘信息；</li>
<li>nova-compute生成Hypervisor驱动需要的数据，并且在Hypervisor上执行请求（通过libvirt或者API）</li>
</ol>
<p>参考链接：<a href="https://ilearnstack.com/2013/04/26/request-flow-for-provisioning-instance-in-openstack/comment-page-1/" target="_blank" rel="external">Request Flow for Provisioning Instance in Openstack</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;openstack在创建虚机的过程中nova的每个服务都扮演了什么角色，以及它们是如何协作的？&lt;/p&gt;
    
    </summary>
    
    
      <category term="openstack" scheme="http://yoursite.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>妖刀，潘帕斯草原上永远的雄鹰</title>
    <link href="http://yoursite.com/2017/07/19/about-basketball-about-Manu-Ginobili/"/>
    <id>http://yoursite.com/2017/07/19/about-basketball-about-Manu-Ginobili/</id>
    <published>2017-07-19T15:36:11.000Z</published>
    <updated>2017-12-20T02:37:04.297Z</updated>
    
    <content type="html"><![CDATA[<p>马努·吉诺比利，效力于NBA圣安东尼奥马刺队，球衣号码20号，司职得分后卫。左手球员，善于蛇形突破和远射，并有独门绝技欧洲步。巅峰期间就是无解般的存在。曾经凭借一己之力摧毁了活塞钢铁般的防守。江湖上一直流传着这样一句话：顺境看帕克，逆境看邓肯，绝境看马努。<br><img src="http://ot8956ufo.bkt.clouddn.com/Manu_01.jpg" alt=""><br><a id="more"></a><br>今天最振奋的消息莫过于听到吉诺比利在和马刺正在谈续约的新闻了。</p>
<p>NBA2016-2017赛季马刺的最后一场比赛结束之后，就以为这估计是马努在NBA的最后一场比赛了，虽然有不舍，但是没有到了不能接受的地步，毕竟年龄也不小了，为篮球奋斗了半辈子，也是该好好休息了。这时候选择退役也是情理之中。</p>
<p>如果这个新闻成真的话，对于我自己来说，也不会有太大的喜悦。毕竟随着年龄的增大，身体往往有时候跟不上意识，导致在场上犯很多低级的错误，对很多不了解他从前的人，还以为他是马刺的毒瘤呢。</p>
<p>很早以前，马刺是一只观赏性不那么强的球队，全联盟最低的回合数，即使拥有全联盟最强的四号位，同时马刺也是联盟收视率的毒瘤，斯特恩的眼中钉，肉中刺。那时候特别不喜欢看马刺队的比赛，比赛节奏慢，主教练永远强调的是防守、团队意识，即使是强如邓肯如果犯了错误，波波老爷子也会立马叫暂停，照骂不误。对于喜欢湖人、喜欢Kobe的我来说，实在是对马刺提不起兴趣。但是马刺的强大是客观存在的，除了在2011年由于吉诺比利的受伤意外的被灰熊给黑八，每年的季后赛成绩都非常优秀。就是一个这样严谨，每个回合都强调战术，对失误零容忍的球队，却有一个游离于体系之外的人，而且有时候他会犯一些低级的错误，甚至是不可饶恕，还不喜欢听教练的指挥，经常自己单打，这个人就是我们熟悉的妖刀–<strong>马努·吉诺比利</strong>。</p>
<p>最早江湖上关于妖刀的传说就是他徒手抓麻雀的事，一时传为美谈。关于他其它的事就知之甚少了。</p>
<p>关于吉诺比利的三个镜头：<br>镜头一：<br>那是2014年西部决赛的第二场比赛，马刺主场。在第二节比赛还剩两分多钟时，马刺球权，吉诺比利将球运到左侧底角，此时遭遇双人包夹，就在这电光火石一瞬间，吉诺比利左手单手将球使劲甩出，只见篮球飞过了整个底线，砸在了右侧底角的格林，格林手起刀落，篮球在空中划过一道完美的弧线，空心入网。天马行空，鬼斧神工，上帝之手，还能有什么更好的形容词来形容这个传球吗？注定是可以载入史册的一个助攻。吉诺比利挑战了人类的想象力，这么长距离的横传，最后还准确无误的落入到格林的手中，这需要多大的想象力和多么夯实的基础啊！从此路转粉。<strong>场上没有我传不到的地方。</strong><br>镜头二：<br>还是2014年，不过是总决赛的第五场比赛，马刺用行云流水、水银泻地般的进攻，打的热火云里雾里，毫无招架之力，虽然吉诺比利在球队中扮演的角色不再是那么重要，但是本场比赛最精彩的镜头中他却是主角。其实这场比赛刚开始的时候马刺是属于追分的一方，这个扣篮之前，马努已经有一个2+1、后撤步三分的发挥了。只见他慢悠悠将球带过半场，在弧顶时，突然一个蛇形突破，硬生生从人群当中杀出一条血路，迎着波什的封盖就是一记重扣，顿时引爆全场，同时也打掉了热火的信息，决定了比赛的走向。兵不血刃，马刺干净利落的干掉了热火。妖刀使用行动告诉大家：<strong>你大爷永远是你大爷</strong>。<br>镜头三：<br>NBA2016-2017赛季的西部半决赛第五场，天王山之战，谁赢谁就会占据主动，可以说是一场决定生死的比赛。比赛理所当然的进入到了加时，虽然在比赛的最后时刻是格林的发挥让马刺赢得了三分的领先。但是还是给火箭留下了扳平比分的可能，火箭的最后一攻交给了本场比赛已经取得三双的哈登，哈登迅速的摆脱了妖刀，只见哈登在三分线外张弓搭箭，一记三分眼见就要射出，但是没想到背后跳出一个妖刀，眼疾手快，盖掉了哈登的三分。让火箭梦碎天王山，可想而知第六场比赛即使是缺少了帕克，马刺也大比分的赢了火箭，哈登在场上完全变了一个人，发挥平平，是火箭输球的罪魁祸首。这个盖帽看了无数次回放，你可以很清晰的看到，妖刀作为一个防守者，已经失去了身位优势（落后哈登一个身位），还抢先起跳，在空中等着哈登，等着哈登的球送到他的魔鬼手掌之下。至此，这个盖帽，完美。精准的预判，强大的心脏。要知道，哈登是一个很善于造犯规的人，尤其是三分线外，如果妖刀的手有丝毫的挥动，直接就是三分犯规，哈登是要罚三次球的（哈登的发球命中率是非常高的），很有可能比分是要追平的。即使是这样，妖刀还是赌了一把，不过庆幸的是这一次赌赢了，不像2006年的那一次，赌输了，结果就是直接丢掉了总冠军。<strong>妖刀出鞘，刀刀见血。</strong></p>
<p>对于马刺球迷来说，妖刀即是撒旦又是耶稣。</p>
<p>接下来需要引用一下张佳玮关于妖刀的评价了：</p>
<ul>
<li>FIBA史上最好的得分后卫之一。</li>
<li>NBA史上得分后卫，论组织策动能力，最顶尖的五人之一。</li>
<li>史上得分后卫里最好的挡拆策动者之一。</li>
<li>顶尖的大心脏。</li>
<li>在所有篮球内涵——包括篮球意识、智商、团队精神、预判、胆略、狡猾、决策——都是历史级的伟大。</li>
<li>NBA史上最好的外籍得分后卫。没有之一。</li>
</ul>
<p>关于马努·吉诺比利，三天三夜也说不完。</p>
<p>相关链接：<a href="https://www.zhihu.com/question/20794361/answer/17162513" target="_blank" rel="external">https://www.zhihu.com/question/20794361/answer/17162513</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;马努·吉诺比利，效力于NBA圣安东尼奥马刺队，球衣号码20号，司职得分后卫。左手球员，善于蛇形突破和远射，并有独门绝技欧洲步。巅峰期间就是无解般的存在。曾经凭借一己之力摧毁了活塞钢铁般的防守。江湖上一直流传着这样一句话：顺境看帕克，逆境看邓肯，绝境看马努。&lt;br&gt;&lt;img src=&quot;http://ot8956ufo.bkt.clouddn.com/Manu_01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="体育" scheme="http://yoursite.com/tags/%E4%BD%93%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>在成长的过程中，我丢失了哪些东西</title>
    <link href="http://yoursite.com/2017/07/19/about-adolescency-and-about-restless/"/>
    <id>http://yoursite.com/2017/07/19/about-adolescency-and-about-restless/</id>
    <published>2017-07-18T16:07:56.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作性质的原因，造成了日常生活非常忙碌的假象，进而也不愿意去浪费时间去思考关于自己的一些事情，尤其是这些事情对未来没有丝毫的影响。种种原因吧，导致对过去有意义的的时光里发生的一些有趣的事情也渐渐给遗忘了。好不容易在这个时间段想去回忆一些东西，记录下来，当然了，不是为了要证明什么，只为了让自己对以往有一个说法。<br><a id="more"></a></p>
<h4 id="成长，仅仅是年龄的增长吗？"><a href="#成长，仅仅是年龄的增长吗？" class="headerlink" title="成长，仅仅是年龄的增长吗？"></a>成长，仅仅是年龄的增长吗？</h4><p>相信很多人对于这个问题的答案都是否定的，成长不仅仅是意味着年龄的增长，同时伴随着年龄一块增长的估计还有你的体重。<br>很多人都是拒绝长大的， 因为年龄越大你需要承担的责任就越大。小的时候想要快快长大， 因为眼里只看到长大了就能够做很多现在做不了的事情，例如：长大了可以有自己的零花钱，长大了就不再需要听父母的唠叨了，长大了就可以去外边的世界了，等等好多事。但是等到这些东西真正的实现了，却没有那么多的惊喜。一方面是随着年龄的增大自己的眼界和欲望也在扩大；另一方面，更重要是物质世界的五彩缤纷让我们无暇去停留、去回顾、去思考。总是在计划接下来的脚步，总是在抱怨生活对自己的不公，却不会停下脚步，去总结自己。<br>在大学的四年里是我人生中最肆无忌惮的四年，虽然这四年的时候可以用一辈子的时间去回忆，但是从不觉得自己这四年的时光是充足的、是处于上升期的。学业一事无成，还养成了办事拖延的坏习惯。但是有一件事自始至终都在坚持，那就是阅读。<br>一天当中最兴奋，最幸福的时光就是凌晨00:00到2:00的时光，那是属于我自己一个人的时光，一盏台灯，一壶茶，我，还有一本书。这一个多小时我是不属于这个世界的，可以猜想，整栋楼里这么晚，估计只有我一个人在做这件事了。虽然每天都只有短短的不到两个小时的时光，但是这短短的两个小时让我明白了我是一个独立的个体，我应该有自己独立的行为，有自己独立的判断，永远不要人云亦云。我是一个独立的人，我不属于我父母，更不属于哪个集体，我只属于我自己，我可以做一切我想做的事情，包括静静的哭，不出声的笑，甚至我可以一支接一支的抽烟，这就给我传递了一个很强的信号：<strong>我可以完全的控制我自己，包括我的行为，我的思想，甚至我的未来</strong>。我再也不需要去依靠别人证明我自己。当我接受到这个信号时，我感觉我一瞬间开窍了，真的是人生就此不同。<br>当这些信念开始真正的支配我的生活时，我能感觉到我成长了，我不只是生活独立了，我的思想也在走向独立的路上。虽然到现在为止有时候在我不知道的一些领域还在接受着他人的支配，但是总体上我迈向了成长的一大步。</p>
<h4 id="成长，我失去了什么？"><a href="#成长，我失去了什么？" class="headerlink" title="成长，我失去了什么？"></a>成长，我失去了什么？</h4><p>虽然可以明显的感觉在成长的过程中自己在逐渐的失去一些东西，但是如果不细细的去想一想，失去就会失去，连曾经存在的意义都跟着一块消失了。<br>失去最多的应该是<strong>勇气</strong>吧。知道的东西越多，也就越畏惧。在事情还没做之前，随着你经验的增加，你就可以把这件事情的所有的风险基本上都考虑到，考虑的越多，做下去的勇气也就越少。导致很多事情都胎死腹中。有很多事情都被我们一句<strong>没有时间</strong>给扼杀了。其实有很多事情都是仓促之间做成的。<strong>时间就像海绵里的水，挤挤总是有的</strong>。总想给某件事腾出很富裕的时间去做，这件事往往最后都会有一个烂尾。<br>当然对我而言，伴随着成长，有一种感觉永远也不会在回来了。那是一种<strong>心动的感觉</strong>。不知上一次心动是多长时间以前了，久到快要忘了是什么感觉了。心动时的羞涩，内心的惴惴不安和躁动，强烈的表现欲和不追求回报的付出，真的是不奢求什么，一个肯定的眼神可以让我高兴一整天，就像是打了兴奋剂，整个世界里都是那一个人。虽然有可能忘了那个人，但是这种感觉是一种财富，虽然我现在不会再有了，这就显得更加的珍贵了。就当是风没有刮过，你没有来过，我没有爱过。</p>
<p>舒适和毫无波澜的生活让我毫不犹豫的选择了颓废，选择躺在床上而不是走在路上，选择去大街上撸串喝酒而不是风餐露宿，不是激情四射而是毫无顾忌的吹牛逼，选择夸夸其谈而不是一味的保持沉默，选择张扬自己的浅薄而不是大智若愚。<br>我恨急了现在的自己，大腹便便，心口不一，尸位素餐……。以前总听别人说：你肯定会变为一个你以前最讨厌的人。一语成谶，果不其然，我已经变成了一个我以前最讨厌的人。不只是对他人不诚实，我学会了欺骗自己，不只是在行为上，在内心深处我也开始安利自己，给自己的虚伪披上美丽的伪装。<br>在成长的过程中，我彻底迷失了自己，一直到现在都没有遇到曾经无比期盼的<code>我</code>，希望可以在某个地点、某个时间与<code>你</code>相遇，一起谈论曾经共同的自己，那些美好，那些感动，那些狂妄和值得铭记的瞬间。</p>
<p>虽然成长的代价如此之大，还是要拼命的往前走，走啊走啊走，有一天会猛然惊醒：你还是那个坐在台灯前的少年，嘴角划过一丝狡黠的微笑，谁也不明白这笑容里的含义，只有你知道。</p>
<p>记录，给自己留下曾经活过的证据。</p>
<p>丁酉年 七月十九日 凌晨 忽有所想</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作性质的原因，造成了日常生活非常忙碌的假象，进而也不愿意去浪费时间去思考关于自己的一些事情，尤其是这些事情对未来没有丝毫的影响。种种原因吧，导致对过去有意义的的时光里发生的一些有趣的事情也渐渐给遗忘了。好不容易在这个时间段想去回忆一些东西，记录下来，当然了，不是为了要证明什么，只为了让自己对以往有一个说法。&lt;br&gt;
    
    </summary>
    
    
      <category term="我" scheme="http://yoursite.com/tags/%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>永远不要放弃自己</title>
    <link href="http://yoursite.com/2017/07/13/do-not-giving-up-yourself/"/>
    <id>http://yoursite.com/2017/07/13/do-not-giving-up-yourself/</id>
    <published>2017-07-13T13:04:54.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近的工作不是很顺利，连带着影响了自己的生活，所有想着静静的坐下来，沉淀沉淀自己，进而给自己一些行而有效的建议，不让自己永远颓废下去，走上不归路。<br><a id="more"></a><br>在生活中，有时候心情会很糟糕，用言语无法形容时，确实是很无奈，都不知道该怎么说，别人都没办法帮你。问题迟迟得不到解决，接下来就开始烦躁，身体不舒服，无所事事，从而开始怀疑自己，怀疑一切，这种心情糟糕透了。</p>
<p>难道只能等吗？等问题变得柳暗花明吗？我看这样是不对的，这样在下次情况来临之际，依旧还是会出现这种情况，人是不会成长的，经历、经验永远不会长进。有一句名言说的好：故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，增益其所不能。</p>
<p>越是困难来临之际，越是要勇敢面对，坚定地去解决它，而不是一而再的躲避，因为躲避根本解决不了问题。</p>
<p>就说这次换部门的事，虽然领导安排的并不是openstack相关的工作，而是一些和以前完全不相关的东西。其实内心深处是抵触的，是不想做的，所以才有了后来的无能为力和抱怨。既然领导已经安排了，就要想方设法的去完成，而不是尽全力的给自己不做的理由：没有完整的资料啊!没有人教啊！这个以前根本就没有接触过，怎么就一下子就交给我了！拿这些理由搪塞自己。这些都是懦夫才做的，从来没有往积极的方向想过这件事，也从来没有一个可行的计划，一切都朝着错误的方向发展，这才导致了如今的局面，一切的一切的始作俑者都是自己。而且这个社会永远不会因为你自以为的可怜而去可怜你，勇敢起来，直面挫折。真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。而不是抱怨、躲避和自怜。</p>
<p>给自己的几点忠告：</p>
<ol>
<li><strong>减少情绪的波动</strong>！不要受情绪的支配，因为只有下等人才会让情绪支配自己的大脑。谦谦君子，温润如玉！</li>
<li><strong>平常的工作当中不要急躁，不要急于求成</strong>。成功是一个很漫长的过程，是循序渐进的，是一步一个脚印走出来的，不是一步登天。有句俗话说的好：不积跬步，无以至千里；不积小流，无以至江海。急于求成是成功的一块绊脚石。</li>
<li><p><strong>不要虚荣</strong>。虚荣心这种东西，很容易上瘾，不要对自己做不真实的评价，有时候不只是能欺骗别人还会欺骗自己。爱慕虚荣会让你走向自大的深渊，直至万劫不复。其行为主要表现在：</p>
<ul>
<li>和朋友的聊天当中不承认自己的过错和过往；</li>
<li>在公众场合故意表现的高高在上，故意展现自己的优势；</li>
<li>积极期待别人的认可，有时候为了应承别人而说谎；</li>
</ul>
</li>
<li><strong>严于律己，宽于律人</strong>。 对待自己要严谨，对待他人要宽容。往往我们都会对别人严格而对自己放纵，有一句话可以与君共勉：有多自律，就有多自由。</li>
<li><strong>详细的规划</strong>。不只是工作，生活当中的小事也要有规划，这样做起来才会有所依据，不至于惶恐。</li>
</ol>
<p>遇到不顺心的事，一定要积累自己的解决方法和方式。要不然这次出现的困难就没有了意义。</p>
<ol>
<li>首先找到问题的源头，从根本点出发，是不是在这一环节自己就出了很大的问题，如果是态度、方法出现了问题，那就要首先更正自己的态度，改变工作的方法；</li>
<li>在态度和方法正确的前提上，尽最大的可能把问题描述清楚，因为如果你都不知道问题究竟是什么，就不要奢望别人能给你解决了。</li>
</ol>
<p><strong>始终坚信自己，对自己永不放弃！</strong> 如果自己都放弃了自己，活着还有什么奔头？年轻的热血在哪里泼洒？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近的工作不是很顺利，连带着影响了自己的生活，所有想着静静的坐下来，沉淀沉淀自己，进而给自己一些行而有效的建议，不让自己永远颓废下去，走上不归路。&lt;br&gt;
    
    </summary>
    
    
      <category term="我" scheme="http://yoursite.com/tags/%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>如何科学的减轻体重？</title>
    <link href="http://yoursite.com/2017/07/09/how-to-scientifically-lose-weight/"/>
    <id>http://yoursite.com/2017/07/09/how-to-scientifically-lose-weight/</id>
    <published>2017-07-09T07:42:09.000Z</published>
    <updated>2017-12-20T02:35:26.208Z</updated>
    
    <content type="html"><![CDATA[<p>身材的问题已经困扰了我好长时间了，最近也在看一些瘦身的书，特此在这整理了一些关于减轻体重的建议，引人而异，切勿100%相信。<br><a id="more"></a></p>
<h3 id="减重的原因"><a href="#减重的原因" class="headerlink" title="减重的原因"></a>减重的原因</h3><p>在减肥之前需要明确自己为什么要减肥？其实，减肥无外乎以下几个原因：</p>
<ol>
<li>有群众反映自己最近有点发福；</li>
<li>肥胖给自己的生活带来了很多的不便，例如：夏天稍微一动就是一身汗，每当照镜子时都有一种杀了自己的冲动，等等吧；</li>
<li>由于肥胖而影响了自己的健康。</li>
</ol>
<p>对于我而言，减肥的主要原因是我对自己的身材实在是看不下去了。站着的时候还好说，每当坐下来，大粗腿，水桶腰，简直无法直视，再加上每次同学聚会时，基本上每个人都会对我的体重嘲讽一番。这些还都是表面上的，其实一个比较客观的事实是：伴随着体重的增加，反映的是最近这段时间，生活的颓废，饮食的不规律，这些问题就会进而影响生活的品质，导致生活质量下降。</p>
<p>尤其是在夏天，每天照镜子时，看到自己四方的脸，似水桶的腰，都会很烦躁，觉得自己不可理喻，而且毕业还没有几年，身材却变了样。都是由于自己平常的放纵，夏天无休止的喝啤酒、吃烤串，再加上自己的工作性质，晚上基本上吃饭的时间都会在八点以后，吃起来基本上就没完，到睡觉躺床上之前，嘴基本上是不会闲着的，这种生活大概持续了半年，体重就疯狂的飙升了将近10KG，整个人都变方了。这个体重上升的过程也反映了我生活的颓废，自我要求的降低，以及性格的失控。所以减肥或者说是减重变得刻不容缓。</p>
<h3 id="体重增加的原因"><a href="#体重增加的原因" class="headerlink" title="体重增加的原因"></a>体重增加的原因</h3><p>先看一个图片：</p>
<p><img src="http://ot8956ufo.bkt.clouddn.com/weight-change.jpg" alt=""></p>
<p>从图中可以明显的看出，影响体重的有两个因素：能量摄入和能量消耗。<br>能量摄入指通过食物所摄入体内的总热量（食物里所包含的能量叫做热量），这个和我们每天的饮食有着直接的关系；<br>能量消耗指每天通过身体代谢（基础代谢）、活动量和食物消化（食物热效应）一共消耗的能量，由于现代社会工作性质的原因，少了大量的体力劳动，在不健身的前提下，其实每天人体的能量消耗是很少的。<br>当我们的能量摄入大于能量消耗时（长时间），多余的能量就会存储下来，变成身上的脂肪（肥肉）。<br>我们可以用数学公式来表示一下：能量摄入 = 能量消耗 + 能量储存。<br>但是这种能量的不平衡是体重增加的真正原因吗？<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3401553/" target="_blank" rel="external">科学验证证明</a>，变胖的原因就是因为人类每天的消耗量在不断的减少的同时，摄入量在不断增加，导致能量储存越来越大，身材就会越来越胖了。</p>
<h3 id="如何减重"><a href="#如何减重" class="headerlink" title="如何减重"></a>如何减重</h3><p>知道了体重增加的根本原因，如何减重的答案就显而易见了：<br>能量摄入 &lt; 能量消耗<br>也就是如果想要体重下降的话，能量摄入一定要小雨能量消耗。重要的是，这是一个长期的过程，需要自己每天的坚持，对生活中每个细节的把控。只有长久坚持下来才会有巨大的效果。<br>知道了大方向该如何做，还是不够的，还需要有具体的执行计划，和具体的落地才可以。有几个具体的建议大家可以参考一下，首先，尽量减少能量的摄入：<br>1、饮食的规律性；不能暴饮暴食，也不能长时间处于饥饿状态，需要在正确的时间内（因人而异）饮食；<br>2、不能忽略早餐的重要性，同时减少晚饭的比重：<br><img src="http://ot8956ufo.bkt.clouddn.com/IMG_0516.jpg" alt=""><br>3、在饥饿的时候可以用水果充饥。<br>再减少能量摄入的前提上，增加能量的消耗，比如：每天坚持跑步、健身等能量消耗较多的运动。<br>说了这么多，总结起来无非就六个字：管住嘴，迈开腿。管住嘴：吃饭张弛有度；迈开腿：坚持生活中必要的锻炼。所有的这一切都需要<strong>坚持</strong>，才能达到减重的效果。</p>
<p>以下几个具体的建议主要是针对我自己的：<br>1、早饭必须吃；除了保证饮食的规律性，其次比较重要的是这样可以减少午餐的摄入量；<br>2、午饭不能吃的太饱、太撑，而且在吃饭的过程中要细嚼慢咽，坚决不能狼吞虎咽；<br>3、晚饭只吃水果，十点之后，不再摄入能量，尤其是坚决不能喝碳酸饮料；<br>4、晚上躺床上时，玩手机时间不能超过十五分钟；</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/26332253" target="_blank" rel="external">[1]. 如何减肥？第1篇：减肥背后的科学原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身材的问题已经困扰了我好长时间了，最近也在看一些瘦身的书，特此在这整理了一些关于减轻体重的建议，引人而异，切勿100%相信。&lt;br&gt;
    
    </summary>
    
    
      <category term="健身" scheme="http://yoursite.com/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>oVirt简单介绍</title>
    <link href="http://yoursite.com/2017/07/07/ovirt-simple-introduce/"/>
    <id>http://yoursite.com/2017/07/07/ovirt-simple-introduce/</id>
    <published>2017-07-07T10:17:16.000Z</published>
    <updated>2017-12-20T02:32:38.656Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司的安排，需要熟悉oVirt，所以特别整理出这篇oVirt入门的文章，初步的对oVirt进行一个简单的介绍。</p>
<a id="more"></a>
<p>在介绍oVirt之前，我们需要了解一下什么是虚拟化？</p>
<p>根据百度百科定义，服务器虚拟化技术是将服务器物理资源抽象成逻辑资源（虚拟机），让一台服务器变成几台甚至上百台相互隔离的虚拟服务器，我们不再受限于物理上的界限，而是让CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合，让IT对业务的变化更具适应力的技术。</p>
<p>这个定义对虚拟化技术解释的非常的透彻，进一步可以分析下虚拟化技术对于企业来说可以带来哪些收益，包括但不限于：</p>
<ol>
<li>节约能源。把物理服务器迁移到虚拟机然后集成在一起，很大程度上可以减少物理服务器的数量，降低了物理服务器的能源消耗；</li>
<li>提高数据中心（机房）的空间利用率。使用虚拟化对服务器进行整合会极大的减少数据中心的碳足迹，这意味着少得多的服务器，少得多的网络设备，还有更少的机架，而且这些同样也会减少占地空间。</li>
<li>提高服务运行时间。服务器虚拟化平台都能够提供一系列物理服务器无法提供的高级功能，用来保持业务延续和提高运行时间。比如实时迁移、存储迁移、容错、高可用性还有分布式资源管理。这些功能能够在出现问题时轻松快速的把虚拟机从一台服务器上移动到另一台，同时还能确保业务的延续。</li>
<li>隔离应用。在没有虚拟化技术时，企业为了隔离应用，数据中心通常使用一台服务器一个应用的模式，在这种模式下，应用越多服务器就回越多，成本就回越来越高。而通过服务器虚拟化提供的应用隔离功能，你只需要很少几台物理服务器就可以建立足够多的虚拟服务器来解决这个应用隔离的问题。</li>
<li>帮助你走入云计算。通过虚拟化你的服务器，把底层硬件（比如：存储）抽象出来，这可以说已经为搬到云里做好了准备。</li>
</ol>
<h3 id="oVirt概述"><a href="#oVirt概述" class="headerlink" title="oVirt概述"></a>oVirt概述</h3><p>oVirt（open Virtualization）是一种虚拟管理应用程序。意味着它可是使用oVirt管理界面（the oVirt engine）去管理硬件节点，存储和网络资源，同时它也可以部署和监控运行在数据中心的虚拟机。</p>
<p>如果你对VMware的产品熟悉的话，其实oVirt就类似于VMware的vSphere。oVirt服务作为红帽企业虚拟化产品的基石，是RHEV的一个上游项目，新特性都是先在oVirt上开发，之后才会出现在企业版的产品中</p>
<h3 id="oVirt体系结构"><a href="#oVirt体系结构" class="headerlink" title="oVirt体系结构"></a>oVirt体系结构</h3><p>一个标准的oVirt部署珠宝包含三部分：</p>
<ol>
<li>oVirt-engine，用于部署，监控，移除，停止和创建虚拟机镜像，配置存储和网络等。</li>
<li>一台或多台云主机（nodes），用于运行虚拟机（VMs）。</li>
<li>一个多个存储节点，用于保存与上述虚拟机相关的镜像和ISO文件。</li>
</ol>
<p>节点（nodes）是安装有VDSM和libvirt的Linux发行版，节点同时会安装一些额外的包，这些包可以轻松的实现网络和其它资源的虚拟化。</p>
<p>存储节点可使用常用的基于文件系统以及基于块设备的共享存储（nfs、iscsi、fc），还能支持分布式文件系统 glusterfs。存储节点被聚合为存储池，保证高可用性和底冗余。</p>
<p>下图为oVirt的系统架构：<br><img src="http://ot8956ufo.bkt.clouddn.com/ovirt-system-architecture.png" alt="image"><br>从上图中可以看到，oVirt通过VDSM将服务器抽象为oVirt-Node节点，这样就保证了服务器节点对管理节点有一致的试图，从而使得管理节点对集群的管理方式更加清楚。而管理节点运行oVirt-engine，为平台管理提供了丰富的功能。oVirt-engine和VDSM是oVirt云平台最关键的两大组件。</p>
<h4 id="oVirt-engine"><a href="#oVirt-engine" class="headerlink" title="oVirt-engine"></a>oVirt-engine</h4><p>oVirt engine是一个基于Jboss的Java应用程序，是作为web服务运行的。该服务直接与服务器的VDSM通信，以此在主机上执行虚拟机的部署，启动，停止，迁移和监控操作，并且它能以存储中的模板来创建新镜像。</p>
<h4 id="VDSM（Virtual-Desktop-and-Server-Manager）"><a href="#VDSM（Virtual-Desktop-and-Server-Manager）" class="headerlink" title="VDSM（Virtual Desktop and Server Manager）"></a>VDSM（Virtual Desktop and Server Manager）</h4><p>VDSM是使用Python开发的一个组件，它为oVirt engine提供了所有主机、虚拟机、网络和存储管理功能。</p>
<p>下图为VDSM的内部机制：<br><img src="http://ot8956ufo.bkt.clouddn.com/VDSM_architecture.png" alt="image"></p>
<p>通过上图可以看出，vdsm通过vdsm API对外提供服务。vdsm实现了所在主机的虚拟化抽象，使得主机转化为统一的虚拟化主机对外提供虚拟化服务。</p>
<p>参考文献：《合型桌面云高可用性研究与实现》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司的安排，需要熟悉oVirt，所以特别整理出这篇oVirt入门的文章，初步的对oVirt进行一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ovrit" scheme="http://yoursite.com/tags/Ovrit/"/>
    
  </entry>
  
  <entry>
    <title>客户端无法连接MySQL服务</title>
    <link href="http://yoursite.com/2017/06/26/the-client-connect-mysql/"/>
    <id>http://yoursite.com/2017/06/26/the-client-connect-mysql/</id>
    <published>2017-06-26T02:40:07.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍MySQL客户端无法连接（远程连接）MySQL服务器的原因。<br><a id="more"></a><br>这里就不在过多的介绍MySQL的安装方式，不过需要的同学，可点击<a href="http://www.itdadao.com/articles/c15a1407688p0.html" target="_blank" rel="external">CentOS 6.5 版本下 MySQL 5.1.73 版本的安装</a>查看。</p>
<p>首先介绍一下服务部署情况：</p>
<table>
<thead>
<tr>
<th>服务器</th>
<th>服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务器A</td>
<td>MySQL服务</td>
</tr>
<tr>
<td>服务器B</td>
<td>WEB服务</td>
</tr>
</tbody>
</table>
<p>MySQL服务和web服务都部署成功以后，去登陆服务器B启动web服务，发现web服务启动异常，一直在提示无法连接到数据库，这就尴尬了！</p>
<p>首先猜测，有可能是服务器B的防火墙设置不正确，MySQL服务所需的3306端口没有开放。</p>
<p>登陆服务器B，查看，确实3306端口没有开放，于是调用如下指令开启3306端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> /sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</div></pre></td></tr></table></figure>
<p>然后保存：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> /etc/rc.d/init.d/iptables save</div></pre></td></tr></table></figure></p>
<p>再次确认3306端口是否已打开：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> /etc/init.d/iptables status</div></pre></td></tr></table></figure></p>
<p>服务器B打开3306端口后，重启服务器A的web服务，发现还是在一直报异常，无法连接数据库！这就纳闷了？还有什么没有修改的吗？为什么通过root用户无法远程连接呢？</p>
<p>查了半天资料发现：<strong>安装了MySQL之后，MySQL的root用户默认是不开放远程访问权限的</strong>。也就是说root用户默认只能通过本地连接。</p>
<p>所以安装完MySQL以后需要我们手动去为root用户添加远程访问权限，具体操作如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">mysql&gt;</span> grant all on *.* to root@'%' identified by 'your_password';</div></pre></td></tr></table></figure></p>
<p>然后重启MySQL服务就OK了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/mysql restart</div></pre></td></tr></table></figure></p>
<p>重新启动web服务，发现服务终于启动正常了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍MySQL客户端无法连接（远程连接）MySQL服务器的原因。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>读书以及生活</title>
    <link href="http://yoursite.com/2017/06/24/the-read-and-the-life/"/>
    <id>http://yoursite.com/2017/06/24/the-read-and-the-life/</id>
    <published>2017-06-24T03:59:10.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目有点大，有点漫无边际，而且貌似我自己也没有太多的资格去谈论这个话题，一个是读的书不多，二是生活经历不太丰富，但是我还是想以自己的生活经历去谈一谈自己的想法。<br><a id="more"></a><br>抛出一个问题，读书到底能给人带来什么？或者说能给人带来什么收益？</p>
<p>首先，第一点，读更多的书不会让自己再去纠结或者思考这个问题的答案；</p>
<p>其次，有更多的人说，有那么多手段可以达到读书的效果，为什么还要读书，结果不都一样吗？为什么非要把读书弄的这么高高在上？</p>
<p>生活当中永远都是最真实的体验，这远比读小说来的真实，甚至小说的故事还是来源于生活，为什么我们每天都在和生活打交道，反而要舍近求远，去通过读书来感受、体验生活？虽然所有的一切来源于生活，但是悲催的是，这个弥足珍贵的机会只有一次，而且永远不会回放，你永远无法以一个旁观者的角度去审视自己，你只能生活在当下，哪怕往前一秒你都无法回去。无比幸运的是 ，你可以通过读书，找到一个和你相似的自己，这样就可以以一个旁观者的身份去看待自己的一生，真正的返现自己。一个好的作者，虚构出的故事，就越真实，能够让你置身其中，找出故事中的你。</p>
<p>接下来就说一组数据：</p>
<p>全世界每年阅读书籍数量排名第一的犹太人，平均每人一年读书64本，而中国近13亿人口，出去教科书，平均每人一年读书1本都不到。自诺贝尔设立以来，犹太人共拿走了20%的化学奖、25%的物理奖、27%的生理与医学奖、41%的经济学奖、12%的诺贝尔文学奖，同时还拿到了1/3以上的普利策奖、1/3以上的奥斯卡奖，而犹太人在世界上的人口只占0.3%。</p>
<p>难道这些冰冷的统计数字，不能说明很多问题吗？</p>
<p>不说这个问题了，接下来就说说我自己的故事吧！</p>
<p>从喜欢读书到开始读书，到现在已经五六年了！虽然当时开始读书的动机不是太单纯，但是到真正沉迷其中的时候，早已没有什么动机了，只是简单的沉迷文字和故事的魅力罢了。但是要说阅读对我自己到底有什么用？可以给自己带来什么实质性的利益？我也不知道，喜欢阅读并且付出大量的时间去寻找自己喜欢的作者，喜欢的书，喜欢这个过程。开始的打发时间，进而沉迷其中，最终变成了饥渴，变成了生活当中不可或缺的一部分。</p>
<p>这么长时间下来，读了这么多的书，看了这么多的人和事，并且目睹了那么多的分别和相聚，无论结局是幸福还是悲惨，从开始的无法理解，到现在的坦然面对，这个过程就是自我的沉淀、精神的升华，使得苦难变得那么的理所应当，挫折也成了生活的一部分。</p>
<p>冰岛、阎连科、刘青云、路遥。最喜欢的几个作家、艺术家。</p>
<p>北岛的诗和散文是真正的美，让你可以感受到文字原来可以这样沉迷、舒适。</p>
<p>阎连科的魔幻现实主义手法让我第一次看到了自己的内心世界，文字有时候可以是一把匕首，一句话就可以拆穿你的伪装，让你无所适从，让你必须直面自己的虚荣和做作。这是一个对自己坦承，并且对社会负责任的作家，只不过有时候会让一些伪装了很久的人突然被拆穿，会愤怒、会攻击、会千夫所指，所以有一部分书理所当然的成了禁书。但是每当读他的书，总会让你心惊肉跳，往往就会觉得自己就是书中的主人公，终于可以以一个局外人的角度审视自己，会对镜中的自己咬牙切齿，甚至痛恨自己的虚与委蛇、爱慕虚荣。</p>
<p>一个对自己内心不诚实的人，生活中不仅需要骗其他人，甚至在没有人的时候还要去努力的骗自己，给自己一个无比正当的理由去向自己解释自己的物质和无耻。在《风雅颂》中，阎连科对主人公面对诱惑时心理状态的描写可以说是如火纯青，拿捏到位，以及对场面的控制。这需要一双怎样的眼睛啊，才能具有这样的穿透力。</p>
<p>刘青云，这是到目前为止，我见过的人当中，最会讲故事的人。一个可以把芝麻大点的小事，写到它一步一步变成西瓜那么大，而且每一个环节都是那么理所当然。这种对人心的把控力，在读其著作的时候无数次让人叹为观止。而且他本人沉稳大气，讲故事永远都是娓娓道来，有理有据，但故事的结局总是那么不可思议。</p>
<p>路遥，这个人写的每一段文字，都让人着迷，再读《平凡的世界》时，我分明看到了自己，第一次自己与自己有了碰撞，第一次对自己、对未来有了那么清晰的认知，让我不再飘渺，不再沉迷于北岛的愤懑于凄苦，不再悔恨夹边沟的一切，开始接受不完美的自己，承认他人的优秀，学会脚踏实地。非常清晰的记得，那是一个仲夏的午后，读完这本书之后，非常心平气和的接受了书中每个人的结局，没有幽怨与不满，合上书，平静的去操场散步，那一刻，我很确信，我是这个世界最幸福的人，至少在那一刻，突然觉得自己完整，自己可以去选择自己要走的路，去努力选择自己的人生。走着走着，眼泪就掉下来了。我就是我，平凡但是不平庸，可以欺骗他人，但是绝对不会欺骗自己的内心。</p>
<p>《血色浪漫》，让我知道了青春就是要热血，要躁动，什么都能辜负，但是青春，要肆无忌惮。</p>
<p>《在路上》，虽然每天都会在路上，但是到目前为止，没有过一次在路上的感觉，始终在意的都是起点和终点，而没有在意在路上的潇洒和自由，在路上的不可思议。</p>
<p>应该每隔一段时间，都让自己有一次在路上的体验，动荡不安、刺激、离别、又出发，最后都会趋于平静。</p>
<p>《夹边沟记事》，夹边沟这块土地地下埋着无数的冤魂，有的人微不足道，但是他们的故事很少有人提起，这是一本永远不会火的书，因为它是消极、悲惨的。希望在有朝一日，这些人会被提起，这一段历史会为大众所知，人们可以接受自己曾经犯下的不可描述的错误。愿逝者安息。</p>
<p>《亮剑》，虽然有可能更多的了解是通过影视，无意之间读了都梁老师的《亮剑》，第一次，让我知道了，我们始终都活在别人的控制中，想让你知道的，会让你看到和听到，不想让你知道的，你不会知晓，就是这么残酷。想知道他们不想让你知道的，就自己去寻找，总是会有那么一群人不会欺骗自己、欺骗大众、不忍颠倒黑白，告诉你真相。</p>
<p>所有的这些构成了现在的我，平凡但不平庸，永远真诚的面对自己。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题目有点大，有点漫无边际，而且貌似我自己也没有太多的资格去谈论这个话题，一个是读的书不多，二是生活经历不太丰富，但是我还是想以自己的生活经历去谈一谈自己的想法。&lt;br&gt;
    
    </summary>
    
    
      <category term="我" scheme="http://yoursite.com/tags/%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>centos利用crontab自动备份</title>
    <link href="http://yoursite.com/2017/06/21/centos-crontab-autobackup/"/>
    <id>http://yoursite.com/2017/06/21/centos-crontab-autobackup/</id>
    <published>2017-06-21T07:14:25.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>最近在我们公司的云主机上用Hexo搭建了自己的博客，怕数据有丢失，所以希望能够对博客中的文章进行备份，防止发生意外时损失无法弥补。自己写了一个小的shell脚本用来进行备份，再查询如何定时自动备份时，遇到了crontab这么个东西，但是没想到这个过程还是遇到了很多坎坷，接下来就从两方面介绍一下我对自己的博客的文章是如何进行备份的。<br><a id="more"></a><br>第一步：备份脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">echo "start prepare bakcup"</div><div class="line"><span class="meta">#</span>放置备份文件的位置</div><div class="line">BACKUP_DIR=/mnt/***_backup</div><div class="line"><span class="meta">#</span>需要备份的文件的位置</div><div class="line">NEED_BACKUP_DIR=/root/dir</div><div class="line"><span class="meta">#</span>备份文件的名称</div><div class="line">BACKUP_NAME=***_$(date +"%Y%m%d")</div><div class="line"><span class="meta">#</span>备份保留30天</div><div class="line">DELETE_BACKUP_NAME=***_$(date -d -30day +"%Y%m%d").tar.gz</div><div class="line"><span class="meta">#</span>删除本地30天前的数据</div><div class="line">echo "delete 30 days ago"</div><div class="line">rm -rf $BACKUP_DIR/$DELETE_BACKUP_NAME</div><div class="line"><span class="meta">#</span>开始备份，备份到放置备份文件的文件夹</div><div class="line">echo "start bakcup"</div><div class="line">tar -zcv -f $BACKUP_DIR/$BACKUP_NAME.tar.gz $NEED_BACKUP_DIR/</div><div class="line">echo "end bakcup"</div></pre></td></tr></table></figure>
<p>脚本中分为两部分，首先需要删除30天之前的脚本（默认只保留30天之内的），最后，对目标文件（需要备份的文件）进行解压，并且指定到存储备份的指定位置。</p>
<p>第二步：定时执行脚本</p>
<p>首先需要介绍一下crond,crond是Linux下用来周期性的执行某个任务或等待处理某些事件的一个守护继承，与windows下的计划任务类似。安装完操作系统（UNIX内核）后会默认安装此服务，且服务是启动的。</p>
<p>众所周知，Linux下的任务调度分为两种：系统任务调度和用户任务调度。</p>
<p>系统任务调度：系统需要周期性执行的工作，其配置文件为<code>/etc/crontab</code>，打开后内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SHELL=/bin/bash</div><div class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">MAILTO=root</div><div class="line">HOME=/</div><div class="line"><span class="meta"></span></div><div class="line"># For details see man 4 crontabs</div><div class="line"><span class="meta"></span></div><div class="line"># Example of job definition:</div><div class="line"><span class="meta">#</span> .---------------- minute (0 - 59)</div><div class="line"><span class="meta">#</span> |  .------------- hour (0 - 23)</div><div class="line"><span class="meta">#</span> |  |  .---------- day of month (1 - 31)</div><div class="line"><span class="meta">#</span> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</div><div class="line"><span class="meta">#</span> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</div><div class="line"><span class="meta">#</span> |  |  |  |  |</div><div class="line"><span class="meta">#</span> *  *  *  *  * user-name command to be executed</div></pre></td></tr></table></figure>
<p>其中前四行主要是配置自动任务执行时的一些环境变量，这个非常重要。下边还给出了一个示例，可以明显看出前五位用于定义任务何时执行，但是不同于我们使用的cron表示式，它只能够精确到分，其次是指定执行的用户，最后才是需要执行的命令。</p>
<p>用户任务调度：用户定期要执行的工作。配置文件保存在<code>/var/spool/cron/</code>，文件名就是用户名。</p>
<p>我们需要使用的就是用户级的任务调度就可以，首先需要介绍有关crontab的命令。</p>
<p>介绍命令之前需要确认是否安装了crontab，如果没有需要安装，安装命令<code>yum install crontab</code>，安装成功之后需要手动启动crond服务，<code>/sbin/service crond start</code>,查看是否启动成功，<code>service crond status</code>，同时还可以设置为开启启动，<code>chkconfig –level 35 crond on</code>。</p>
<p><code>crontab [-u user] [ -e | -l | -r ]</code></p>
<p>主要说几个常用的：</p>
<p><code>-e</code>：编辑某个用户的crontab文件内容，如果不指定的用户，默认为当前用户；</p>
<p><code>-l</code>：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容</p>
<p>使用<code>crontab -e</code>创建一个自动任务，具体内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * /root/auto_bakcup_l-zz.sh</div></pre></td></tr></table></figure>
<p>首先验证定时任务是否生效，结果发现并没有执行备份的脚本，猜测有可能是备份脚本中没有配置环境变量，所以导致系统执行任务调度时就存在问题。为了验证是否是环境变量引起的问题，修改了备份脚本，修改后内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">echo $PATH #打印环境变量</div></pre></td></tr></table></figure>
<p>然后自动任务，将备份脚本的echo追加到指定的日志文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * /root/auto_bakcup_l-zz.sh &gt;&gt; /tmp/auto_bakcup.log 2&gt;&amp;1</div></pre></td></tr></table></figure></p>
<p>然后对自动任务进行重启<code>/etc/init.d/crond restart</code>,查看日志文件，发现打印的环境变量为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin:/bin</div></pre></td></tr></table></figure>
<p>与我们在终端下执行<code>echo $PATH</code>输出的环境变量为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/root/.nvm/v6.10.0/bin:/root/jdk1.7.0_79/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</div></pre></td></tr></table></figure>
<p>却有不同，所以有此判断是由于环境变量的原因引起的。</p>
<p>解决办法：在备份脚本的头部需要添加一行代码，<code>source /etc/profile</code>，手动去加载配置文件。</p>
<p>到此自动备份就OK了！</p>
<p><br></p>
<p>参考文章：<a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="external">crontab命令</a>，<a href="https://segmentfault.com/q/1010000000404191" target="_blank" rel="external">crontab定时任务不执行</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在我们公司的云主机上用Hexo搭建了自己的博客，怕数据有丢失，所以希望能够对博客中的文章进行备份，防止发生意外时损失无法弥补。自己写了一个小的shell脚本用来进行备份，再查询如何定时自动备份时，遇到了crontab这么个东西，但是没想到这个过程还是遇到了很多坎坷，接下来就从两方面介绍一下我对自己的博客的文章是如何进行备份的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git push 报错（403）</title>
    <link href="http://yoursite.com/2017/06/21/git-push-error-403/"/>
    <id>http://yoursite.com/2017/06/21/git-push-error-403/</id>
    <published>2017-06-20T22:36:53.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>今天在GitHub上新建了一个Repository，clone到本地后，发现无法进行push，在网上找了看到有很多解决方法，但是试了很多都没有用，最后在Stack Overflow看到有一种解决方案，正好解决了无法push的问题。<br><a id="more"></a><br>报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: The requested URL returned error: 403 Forbidden while accessing https://github.com/2ld/l-zz.cn.git/info/refs</div><div class="line"></div><div class="line">fatal: HTTP request failed</div></pre></td></tr></table></figure>
<p>解决方案如下：</p>
<p>1.edit <code>.git/config</code> file under your repo directory</p>
<p>2.find <code>url=</code> entry under section <code>[remote &quot;origin&quot;]</code></p>
<p>3.change it from <code>url = https://github.com/useraccount/repository.git</code> to <code>url=ssh://git@github.com/useraccount/repository.git</code>. that is, change all the texts before @ symbol to <code>ssh://git</code></p>
<p>4.Save config file and quit. now you could use git push origin master to sync your repo on GitHub</p>
<p>OK，按照以上四步修改完成之后就可以正常push了。<br><br><br>参考：<a href="https://stackoverflow.com/questions/7438313/pushing-to-git-returning-error-code-403-fatal-http-request-failed" target="_blank" rel="external">Pushing to Git returning Error Code 403 fatal: HTTP request failed</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在GitHub上新建了一个Repository，clone到本地后，发现无法进行push，在网上找了看到有很多解决方法，但是试了很多都没有用，最后在Stack Overflow看到有一种解决方案，正好解决了无法push的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>无我编程的十条戒律</title>
    <link href="http://yoursite.com/2017/06/20/The-Psychology-of-Computer-Programming/"/>
    <id>http://yoursite.com/2017/06/20/The-Psychology-of-Computer-Programming/</id>
    <published>2017-06-20T01:57:34.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>本文章主要是对《程序员心理学》中提到的十大原则，进行总结，希望能够引以为戒。<br><a id="more"></a><br><strong>1.接受自己会犯错的事实</strong>。关键是要在错误进入到生产环境之前把它们找出来。所幸的是，除了小部分在喷气推进实验室里开发火箭制导系统的程序员，大部分错误都不会造成致命的后果。所以，我们一定能够而且也应该要学会嫣然一笑，然后继续。</p>
<p><strong>2.不要使用代码来针对个人</strong>。要记住，代码评审的目的是为了找出问题，而且总归会找到问题。如果真的找到了问题，请不要把它作为针对个人的借口。</p>
<p><strong>3.不管你知道多少“秘籍”，总有人比你知道得更多</strong>。如果你开口，他们就会教你更多的东西。在你认为没有必要的时候，学会接受他人的建议。</p>
<p><strong>4.不要不经讨论地重写代码。</strong>“修复代码”与“重写代码”是有明显的区别的。了解这些区别，并在代码评审的框架之内进行程式化的变更，而不是单独作战。</p>
<p><strong>5.尊重比你懂得少的人，并对他们抱以耐心。</strong>与技术人员打交道的非技术人员认为技术人员要么是妄自尊大的讨厌鬼，要么是爱撂挑子的倔驴。所以，我们不要用我们的愤怒和不耐烦去加深他们对我们的这种印象。</p>
<p><strong>6.这个世界唯一不变的就是变化</strong>。敞开胸怀，面带微笑地去拥抱变化。把每一个需求变更、平台变更或工具变更都看成是一个新的挑战，而不是令人厌恶的麻烦。</p>
<p><strong>7.真正的权威来自于知识，而不是职位</strong>。知识造就了权威，而权威会迎来尊重。如果你想要在一个无我的环境里得到尊重，那么充实你的知识吧。</p>
<p><strong>8.坚定你的立场，优雅地接受挑战</strong>。要知道，你的想法有时候会遭到反对。你可以证明自己是对的，但不要试图报复，不要总是叫嚷着“我早就说过”，不要被否定的想法看成是一个牺牲品或者某种战斗口号。</p>
<p><strong>9.不要成为“小黑屋里的人”</strong>。不要躲在小黑屋里写代码，就算偶尔露个面，也只是为了买一杯可乐。躲在小黑屋里只会让你与其他人失去联系，淡出他们的视野，失去控制。在一个开放的协作环境里，你会找不到自己的位置。</p>
<p><strong>10.批评代码，而不是人</strong>。对人好一点，而不是代码。让你所有的评审为代码带来积极的改进，把你的评审与局部标准、程序规范和更好的性能结合在一起。</p>
<p><br><br>原文链接：<a href="https://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659599322&amp;idx=1&amp;sn=0f201ceb0d650637384bdd2aea95bb84&amp;chksm=8be996c8bc9e1fde5c23e6736ff9a4c999a23d0a9b7b819bd155517edea1118a13d81e9f494c#rd" target="_blank" rel="external">StackOverflow创始人关于如何高效编程的清单</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章主要是对《程序员心理学》中提到的十大原则，进行总结，希望能够引以为戒。&lt;br&gt;
    
    </summary>
    
    
      <category term="程序员成长" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>寻找家园，其实是寻找自由</title>
    <link href="http://yoursite.com/2017/06/15/homeland-freedom/"/>
    <id>http://yoursite.com/2017/06/15/homeland-freedom/</id>
    <published>2017-06-15T07:09:20.000Z</published>
    <updated>2017-12-20T02:30:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>《寻找家园》让我知道了人生可以这样苦，但是即使是这样苦，依旧可以很平静的活着，而且写出了如此伟大的巨著。<br><a id="more"></a><br><img src="http://ot8956ufo.bkt.clouddn.com/gaoertai.jpg" alt=""></p>
<h2 id="高尔泰"><a href="#高尔泰" class="headerlink" title="高尔泰"></a>高尔泰</h2><p>高尔泰，著名美学家、画家、作家，旅美学者。这是维基百科上对高尔泰的介绍，旅美学者？不是太赞同，虽然现在高尔泰确实是定居在美国，但是“旅”字不敢苟同。其实我通过阅读高尔泰老师的《寻找家园》之后，我觉得高尔泰是一个简单但是充实，性格乖张并且与众不同的人，虽然命运无数次的折磨他，但是依旧可以乐观的活着。</p>
<h2 id="寻找家园"><a href="#寻找家园" class="headerlink" title="寻找家园"></a>寻找家园</h2><p>无数次的在深夜无人之时拿起这本书，有时候只是为了安慰一下自己，在这个世界上，某个地方，有一个和你很相似的人，一样孤独。</p>
<p>不是寻找家园，而是寻找自由。</p>
<p>后续更新。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《寻找家园》让我知道了人生可以这样苦，但是即使是这样苦，依旧可以很平静的活着，而且写出了如此伟大的巨著。&lt;br&gt;
    
    </summary>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于域名，关于我......</title>
    <link href="http://yoursite.com/2017/06/10/about-me-domain/"/>
    <id>http://yoursite.com/2017/06/10/about-me-domain/</id>
    <published>2017-06-10T15:32:27.000Z</published>
    <updated>2017-11-01T03:34:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>关键字：自己，记录，回忆<br><a id="more"></a></p>
<h2 id="About-Domain"><a href="#About-Domain" class="headerlink" title="About Domain"></a>About Domain</h2><p><strong><em>Ordinary World</em></strong> 是《平凡的世界》的英译名，《平凡的世界》是路遥老师的作品，路遥老师在写完这本书的第三年就因为肝硬化去世了，也许是因为这部宏伟的不朽的巨著耗费了他老人家巨大的心血，不过庆幸的是在他有生的日子里他的努力得到了回报，矛盾文学奖——中国具有最高荣誉的文学奖项之一，虽然并没有在物质上帮助他。</p>
<p>在大三的时候有幸读到的这本书，当时读完之震撼，现在已经无法详细表述了。但是到现在为止它依然是我内心深处最有力的后盾，少平也是我努力的方向：真诚、朴实，做到真正的内心的强大，才能不畏惧风雨。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p>90后，程序员，具有严重的拖延症，一秒钟看不到自己的手机会恐慌；</p>
<p>懦弱，从来不敢在公众场合发表自己的意见，生怕显示出自己的无知；</p>
<p>脾气反复无常，不以物喜，不以己悲，说的刚好不是我；</p>
<p>身为一个程序员，爱好不是码砖，而是看书，看小说；</p>
<p>喜欢与众不同，标新立异，用外在来掩饰自己的孤独，最后的结果却适得其反。</p>
<p>最喜欢无病呻吟的人，对于这种人，特别有共鸣。</p>
<p><strong><em>. . . . . .</em></strong></p>
<p>关于自己，也许说上个三天三夜也说不完，随着岁月的成长，也许自己本身并不会有太多的变化，变化也许只是自己对自己的认知更加透彻了吧。</p>
<p>越是孤独，就越矫情，最美好的结果莫过于在别人的嘲笑声和在自己的自怜中走向死亡。</p>
<p>喜欢的运动莫过于篮球了，每当心情低落或者生活不如意，篮球是发泄最合适不过的对象，不只是因为能够释放自己，同时也享受在篮球运动过程的乐趣。</p>
<p>喜欢的歌曲，太多，不过有一首足以刻骨铭心，有余音绕梁，三日不绝之意。<a href="http://music.163.com/#/song?id=31445771" target="_blank" rel="external">行歌</a>。</p>
<h2 id="Why-Blog"><a href="#Why-Blog" class="headerlink" title="Why Blog"></a>Why Blog</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>不喜欢在公众场合发表自己的意见，同时倒霉催的是心里又藏不住话，所以只好在虚拟幻境了发发老骚了（心理活动：反正没人打我）。希望这个博客可以记录自己的心里路程，不管是好的坏的，有意义的无意义的；给自己的每个时刻打上烙印、标签。用这些鲜活的文字证明自己活过、经历过。</p>
<h3 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h3><p>希望可以在将来闲暇之时，依然可以有所凭据，去吹牛逼，给别人看，这就是我年轻过的证据，虽然现在已经老了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字：自己，记录，回忆&lt;br&gt;
    
    </summary>
    
    
      <category term="我" scheme="http://yoursite.com/tags/%E6%88%91/"/>
    
  </entry>
  
</feed>
